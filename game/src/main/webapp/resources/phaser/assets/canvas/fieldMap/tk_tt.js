/* --- end generated code --- */
//-- user code here --
//-- user code here --

/* --- start_tk_tt generated code --- */

//Generated by  1.5.1 (Phaser v2.6.2)


/**
 * tk_tt.
 */
function tk_tt() {
	Phaser.State.call(this);
}
/** @type Phaser.State */
var tk_tt_proto = Object.create(Phaser.State.prototype);
tk_tt.prototype = tk_tt_proto;
tk_tt.prototype.constructor = tk_tt;

var ftok_sscheck;
var ftok_plAcheck;
var ftok_plBcheck;

tk_tt.prototype.init = function () {
	this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
	this.scale.pageAlignHorizontally = true;
	this.scale.pageAlignVertically = true;
	this.stage.backgroundColor = '#ffffff';
	
	ftok_sscheck = eval(episodeKey+"_sscheck");
	ftok_plAcheck = eval(episodeKey+"_plAcheck");
	ftok_plBcheck = eval(episodeKey+"_plBcheck");
};
var spop_button_tk_tt;//스타트 후 팝업버튼
var ftok_tt_player;//유저
var cursors_tk_tt;//유저이동을 위한 변수
var ftok_tt_treeG;//울타리그룹
var ftok_tt_colboxes;//충돌박스들

var	ftok_tt_red;//레드
var	ftok_tt_blue;//블루
var	ftok_tt_purple;//퍼플
var	ftok_tt_green;//그린

var ftok_tt_pines; //멀쩡한 파인애플(미구현)
var ftok_tt_grStand;//블루 스탠딩
var ftok_tt_exit;//출구
var ftok_tt_boss;//보스몹

var ftok_tt_BTbox;//블루가말하는 글에 대한 텍스트박스
var ftok_tt_RTbox;//레드가말하는 글에 대한 텍스트박스
var ftok_tt_PTbox;//퍼플이말하는 글에 대한 텍스트박스
var ftok_tt_GTbox;//그린이말하는 글에 대한 텍스트박스

var ftok_tt_surround;//최초안내용 충돌박스
var spop_window_tk_tt;//최초안내용 윈도우
var ftok_tt_confbox;//맵을 나갈지 안나갈지에 대한것인듯
var ftok_tt_confirm;//맵으로 나감 팝업 확인
var ftok_tt_cancel;//맵으로 나감 팝업 취소
var ftok_tt_tarray = ['やっときたね！',"緊急事態だ！"+"\n"+"時間がない！",'怪人たちのリーダーだ！',"東京タワーを襲撃したのは"+"\n"+"ルーシーパだった！","このままでは"+"\n"+"この日本全の観光地が","全部台無しになってしまう！",'こっちだ！'];
var ftok_tt_showtext; //가이드블루로 출력하는 텍스트들의 위치
var gredup;//레드의 애니메이션
var ftok_tt_askingjako;//반복학습의 자코?
var ftok_tt_realjako;//자코의 본모습
var ftok_tt_askingboard;//반복학습대사창
var ftok_tt_ToSS;//Self Study로 이동하는 버튼
var ftok_tt_ToPL;//Private Lesson으로 이동하는 버튼
var ftok_tt_sftextN;//학습이 아직 안 끝났을 때 보여주는 텍스트 상자
var ftok_tt_sftextY;//학습이 모두 끝난 뒤 보여주는 텍스트 상자
var eventbox1_tk_tt;//유저가 충돌하면 이전보스들을 길막이로 등장시키는 박스1
var eventbox2_tk_tt;//유저가 충돌하면 이전보스들을 길막이로 등장시키는 박스2
var eventbox3_tk_tt;//유저가 충돌하면 이전보스들을 길막이로 등장시키는 박스3
var eventbox4_tk_tt;//유저가 충돌하면 이전보스들을 길막이로 등장시키는 박스4
var hinder1_tk_tt ;//길막이1 = 돼지
var hindertext1_tk_tt;//길막1의 텍스트
var hinderbox1_tk_tt;//길막1의 텍스트상자
var hinder2_tk_tt;//길막이2 = 개
var hinderbox2_tk_tt;
var hindertext2_tk_tt ;
var hinder3_tk_tt;//길막이3 = EAGOL
var hindertext3_tk_tt;
var hinderbox3_tk_tt;
var hinder4_tk_tt;//길막이4 = 일단 자코로 대체0
var hindertext4_tk_tt;
var hinderbox4_tk_tt;
var hinderst = ["キキキ゚ー","通さないんだブヒ","ここまででスワン","ここまでくるとわな"];
var lasbosscript = ["キキ゚キ゚-","キキ゚-私は…"];
var lasbosscript2 = ["ホー、よくここまできたの。\nかかってきたまえ。"];
var tk_tt_bgm;

tk_tt.prototype.create = function () {
	//충돌상자로 이동경로를 제한하자. 실제 충돌상0자들1은 보이면 안 되기 때문에 가장 밑바닥, 제일 먼저 배치한다.
	tk_tt_bgm = this.add.audio('Battle_against_Jako1');
	tk_tt_bgm.play();
	tk_tt_bgm.loopFull();
	tk_tt_bgm2 = this.add.audio('Foreigner_theme');
	ftok_tt_colboxes = this.add.group();
	ftok_tt_colboxes.create(637,124,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(535,139,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(443,125,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(558,222,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(366,316,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(366,477,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(366,570,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(366,670,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(174,760,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(173,573,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(343,141,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(243,118,'collisionBoxW',0,true);
	ftok_tt_colboxes.create(637,690,'collisionBox',0,true);
	ftok_tt_colboxes.create(637,493,'collisionBox',0,true);
	ftok_tt_colboxes.create(637,234,'collisionBox',0,true);
	ftok_tt_colboxes.create(735,690,'collisionBox',0,true);
	ftok_tt_colboxes.create(735,493,'collisionBox',0,true);
	ftok_tt_colboxes.create(735,234,'collisionBox',0,true);
	ftok_tt_colboxes.create(544,234,'collisionBox',0,true);
	ftok_tt_colboxes.create(350,234,'collisionBox',0,true);
	ftok_tt_colboxes.create(445,234,'collisionBox',0,true);
	ftok_tt_colboxes.create(255,234,'collisionBox',0,true);
	ftok_tt_colboxes.create(255,360,'collisionBox',0,true);
	ftok_tt_colboxes.create(255,485,'collisionBox',0,true);
	ftok_tt_colboxes.create(350,490,'collisionBox',0,true);
	ftok_tt_colboxes.create(350,695,'collisionBox',0,true);
	ftok_tt_colboxes.create(533,683,'collisionBox',0,true);
	ftok_tt_colboxes.create(250,691,'collisionBox',0,true);
	ftok_tt_colboxes.create(23,677,'collisionBox',0,true);
	ftok_tt_colboxes.create(163,479,'collisionBox',0,true);
	ftok_tt_colboxes.create(25,479,'collisionBox',0,true);
	ftok_tt_colboxes.create(61,442,'collisionBoxW',0,true);
	this.physics.enable(ftok_tt_colboxes, Phaser.Physics.ARCADE);
	ftok_tt_colboxes.setAll('body.immovable',true);
	//충돌상자 끝
	//유저를 감쌀 충돌상자가 필요해졌음 해당 충돌박스들에는 update문에서 충돌이벤트를 걸어두었다.
	ftok_tt_surround = this.add.group();
	ftok_tt_surround.create(675,700,'collisionBox',0,true);
	ftok_tt_surround.create(755,700,'collisionBox',0,true);
	this.physics.enable(ftok_tt_surround,Phaser.Physics.ARCADE);
	ftok_tt_surround.setAll('body.immovable',true);
	//길가다보면 등장하는 이벤트의 트리거인 박스1~4
	eventbox1_tk_tt = this.add.sprite(650,190,'collisionBoxW',0);
	eventbox2_tk_tt = this.add.sprite(456,344,'collisionBoxW',0);
	eventbox3_tk_tt = this.add.sprite(270,447,'collisionBoxW',0);
	eventbox4_tk_tt = this.add.sprite(270,602,'collisionBoxW',0);
	this.physics.enable(eventbox1_tk_tt,Phaser.Physics.ARCADE);
	this.physics.enable(eventbox2_tk_tt,Phaser.Physics.ARCADE);
	this.physics.enable(eventbox3_tk_tt,Phaser.Physics.ARCADE);
	this.physics.enable(eventbox4_tk_tt,Phaser.Physics.ARCADE);
	eventbox1_tk_tt.body.immovable = true;
	eventbox2_tk_tt.body.immovable = true;
	eventbox3_tk_tt.body.immovable = true;
	eventbox4_tk_tt.body.immovable = true;
	//출구를 생성
	ftok_tt_exit = this.add.sprite(650.0, 795.0, 'collisionBoxW', 0);
	//충돌상자 전부 끝
	this.physics.enable(ftok_tt_exit,Phaser.Physics.ARCADE);
	ftok_tt_exit.body.immovable = true;
	//end
	this.add.sprite(0.0, 0.0, 'tk_tt_map');//도쿄타일맵 호출
	//적 NPC들의 이미지를 넣는다.--------------------------------------------------------------------------------------
	ftok_tt_boss = this.add.sprite(87.0, 484.0, 'jakodott', 0);
	var ftok_tt_bossidle = ftok_tt_boss.animations.add('idle', [0,1,2,1], 3, true);//보스의 모션을 애니메이션으로 만들고(무한루프)
	ftok_tt_bossidle.play();//실행한다.
	this.physics.enable(ftok_tt_boss, Phaser.Physics.ARCADE);//실체부여
	ftok_tt_boss.body.immovable = true;
	ftok_tt_boss.visible = false;//일단 보스는 처음엔 안 보이는 상태가 되어야 한다.!!!!!!!!!!!!!!!!!!-------------------------
	//아군NPC들의 이미지를 넣는다.-------------------------------------------------------------------------------------

	f_treeG = this.add.group();//이젠 나무가 아니라 석재울타리다
	f_treeG.create(657, 335, 'sfence_H',0,true);
	f_treeG.create(657, 403, 'sfence_H',0,true);
	f_treeG.create(273, 146, 'sfence_H',0,true);
	f_treeG.create(443, 150, 'sfence_H',0,true);
	f_treeG.create(736, 150, 'sfence_H',0,true);
	f_treeG.create(736, 338, 'sfence_H',0,true);
	f_treeG.create(736, 408, 'sfence_H',0,true);
	f_treeG.create(546, 335, 'sfence_H',0,true);
	f_treeG.create(546, 405, 'sfence_H',0,true);
	f_treeG.create(546, 590, 'sfence_H',0,true);
	f_treeG.create(659, 590, 'sfence_H',0,true);
	f_treeG.create(733, 590, 'sfence_H',0,true);
	f_treeG.create(460, 498, 'sfence_W',0,true);
	f_treeG.create(455, 772, 'sfence_W',0,true);
	f_treeG.create(60, 772, 'sfence_W',0,true);
	f_treeG.create(265, 772, 'sfence_W',0,true);
	this.physics.enable(f_treeG, Phaser.Physics.ARCADE);
	f_treeG.setAll('body.immovable',true);//그룹에 해당하는 객체들을 충돌해도 움직이지 않게 하려면 setAll함수를 이용해야 한다.

	//텍스트상자와 그 안의 텍스트를 출력합시다 =======================================================================================
	guidered_tk_tt = this.add.sprite(690.0, 700.0, 'red', 0);//가이드용 red는 따로생성
	gredup = guidered_tk_tt.animations.add('grup',[9,10,11,10], 5, true);
	this.physics.enable(guidered_tk_tt, Phaser.Physics.ARCADE);//가이드red가 실체를 가진다.
	ftok_tt_grStand = this.add.sprite(300,600,'rstand',0);
	ftok_tt_grStand.scale.setTo(0.25,0.25);
	ftok_tt_grStand.visible = false;
	ftok_tt_textbox = this.add.sprite(450, 600, 'textbox',0);//가이드red의 텍스트상자
	ftok_tt_showtext = this.add.text(465, 630, ftok_tt_tarray[0], { font: "20px Arial", fill: "#000000", align: "left" });
	ftok_tt_showtext.visible=false;
	var converidle = ftok_tt_textbox.animations.add('converidle', [0, 1, 2], 5, true);
	converidle.play();
	ftok_tt_textbox.visible=false;
	guidered_tk_tt.body.immovable = true;
	//------------------------------------------------------------------유저의 캐릭터코드에서 받은 정보로 캐릭터를 출력
	var charcode = userCharUnicode;//남자니여자니?
	if (charcode=='male') {
		ftok_tt_player = this.add.sprite(tk_tt_lastStep.x, tk_tt_lastStep.y, 'maled', 0);	
	}else{
		ftok_tt_player = this.add.sprite(tk_tt_lastStep.x, tk_tt_lastStep.y, 'femaled', 0);
	}
	ftok_tt_player.animations.add('pleft', [3, 4, 5, 4], 5, false);
	ftok_tt_player.animations.add('pright', [6, 7, 8, 7], 5, false);
	ftok_tt_player.animations.add('pup', [9, 10, 11, 10], 5, false);
	ftok_tt_player.animations.add('pdown', [0, 1, 2, 1], 5, false);
	this.physics.enable(ftok_tt_player, Phaser.Physics.ARCADE);//플레이어 객체가 충돌크기를 가지게 설정
	cursors_tk_tt = this.input.keyboard.createCursorKeys(); //알아서 방향키를 지정해준다.
	this.camera.follow(ftok_tt_player);//그냥 설정만 해두면 플레이어로 설정된 객체를 잘 따라다닌다.
	this.world.setBounds(0, 0, 800, 800);//전체 월드맵의 크기를 설정한다. 앞의 0,0은 안건드려도 된다.
	ftok_tt_player.body.collideWorldBounds = true;//유저가 월드맵 밖으로 나가지 못하게 막는다.
	// surrounds에 충돌했을 경우 최초안내메시지창을 띄운다-------------------------------------------------------------
	spop_window_tk_tt = this.add.sprite(450,600,'instruction',0);//팝업창은 보여야한다...
	spop_window_tk_tt.visible = false;
	spop_button = this.add.sprite(550,710,'button',0);//버튼용 함수들 시작
	spop_button.inputEnabled = true;
	spop_button.events.onInputDown.add(wipeout_tk_tt, this); //마우스 클릭버튼을 누를 때에 발동
	spop_button.visible = false;
	//맵을 나가려고 할 때 물어보는 메시지 박스를 생성한다.-------------------------------------------------------------
	ftok_tt_confbox = this.add.sprite(400,600,'askpopup',0);
	//ftok_tt_confbox.scale.setTo(0.5,0.5);
	ftok_tt_confirm = this.add.sprite(600,710,'btn_yes',0);
	ftok_tt_confirm.scale.setTo(0.3,0.3);
	ftok_tt_cancel = this.add.sprite(650,710,'btn_nope',0);
	ftok_tt_cancel.scale.setTo(0.3,0.3);
	//일단 이벤트 호출이 될 때까지는 보이지 않는 상태를 유지시킨다.
	ftok_tt_confbox.visible = false;
	ftok_tt_confirm.visible = false;
	ftok_tt_cancel.visible = false;
//////////////////////////////////////////방해하는 전 보스들에 대한 문장들
	hinder1_tk_tt = this.add.sprite(680,170,'jakodott', 0);
	var idle = hinder1_tk_tt.animations.add('hin1idle', [0, 1, 2], 5, true);
	idle.play();
	hinderbox1 = this.add.sprite(600,120,'textbox', 0);
	hinderbox1.scale.setTo(0.5,0.5);
	hinderbox1.inputEnabled = true;
	hindertext1 = this.add.text(607, 135, hinderst[0], { font: "15px Arial", fill: "#000000", align: "left" });
	hinder2_tk_tt = this.add.sprite(493,342,'buhidott', 0);	
	var idle = hinder2_tk_tt.animations.add('hin2idle', [0, 1, 2], 5, true);
	idle.play();
	hinderbox2 = this.add.sprite(530,370,'textbox',0);
	hinderbox2.scale.setTo(0.5,0.5);
	hinderbox2.inputEnabled = true;
	hindertext2 = this.add.text(535, 380, hinderst[1], { font: "15px Arial", fill: "#000000", align: "left" });
	hinder3_tk_tt = this.add.sprite(300,460,'wantandot', 0);	
	var idle = hinder3_tk_tt.animations.add('hin3idle', [0, 1, 2], 5, true);
	idle.play();
	hinderbox3 = this.add.sprite(335,430,'textbox');
	hinderbox3.scale.setTo(0.5,0.5);
	hinderbox3.inputEnabled = true;
	hindertext3 = this.add.text(342, 443, hinderst[2], { font: "15px Arial", fill: "#000000", align: "left" });	
	hinder4_tk_tt = this.add.sprite(300,600,'eagoldott', 0);
	var idle = hinder4_tk_tt.animations.add('hin4idle', [0, 1, 2], 5, true);
	idle.play();
	hinderbox4 = this.add.sprite(335,560,'textbox',0);
	hinderbox4.scale.setTo(0.5,0.5);
	hinderbox4.inputEnabled = true;
	hindertext4 = this.add.text(343, 573, hinderst[3], { font: "15px Arial", fill: "#000000", align: "left" });
	hinder1_tk_tt.visible = false;
	hinder2_tk_tt.visible = false;
	hinder3_tk_tt.visible = false;
	hinder4_tk_tt.visible = false;
	hinderbox1.visible = false;
	hinderbox2.visible = false;
	hinderbox3.visible = false;
	hinderbox4.visible = false;
	hindertext1.visible= false;
	hindertext2.visible= false;
	hindertext3.visible= false;
	hindertext4.visible= false;
	///////////////////////////////////////////////////////////////////////////////반복학습메뉴///////////////////////
		ftok_tt_askingred = this.add.sprite(200,200,'jakostand',0);//자코?의 스탠딩이미지
	ftok_tt_realjako = this.add.sprite(200,200,'lasbos',0);//최종보스이미지
	ftok_tt_realjako.scale.setTo(0.5,0.5);
	ftok_tt_askingred.scale.setTo(0.5,0.5);
	ftok_tt_askingboard = this.add.sprite(100,600,'Btextbox2',0); //자코?의 텍스트박스
	ftok_tt_askingboard.inputEnabled = false;
	ftok_tt_askingboard.events.onInputDown.add(nexttext_tk_tt,this);//텍스트박스를 클릭해서 텍스트를 넘겨야지
	aboxidle = ftok_tt_askingboard.animations.add('aboxidle', [0, 1, 2], 5, true);
	aboxidle.play();// 텍스트박스의 애니메이션과 재생
	//레드의 텍스트-1 유저가 아직 연습을 모두 진행하지 않았을 때
	ftok_tt_sftextN = this.add.text(150, 650, lasbosscript[0], { font: "22px Arial", fill: "#000000", align: "left" });
	//레드의 텍스트-2 유저가 두 연습을 모두 진행했을 때
	ftok_tt_sftextY = this.add.text(150, 650, lasbosscript2[0], { font: "22px Arial", fill: "#000000", align: "left" });
	ftok_tt_askingboard.visible = false;//일단 다 안 보이게
	ftok_tt_askingred.visible = false;
	ftok_tt_realjako.visible = false;
	ftok_tt_sftextN.visible=false;
	ftok_tt_sftextY.visible=false;
	
	if (ftok_sscheck || ftok_plAcheck || ftok_plBcheck) {
		setfield();
	}
};//create 종료

function setfield(){
	hinder_tk_tt1();
	hinder_tk_tt2();
	hinder_tk_tt3();
	hinder_tk_tt4();
	hinder_atk_tk_tt1();
	hinder_atk_tk_tt2();
	hinder_atk_tk_tt3();
	hinder_atk_tk_tt4();
	guidered_tk_tt.visible = false;
}

tk_tt.prototype.update = function () {
	ftok_tt_player.body.velocity.set(0);//유저의 속도는 키 입력이 없을 시 항상 0이어야만 한다.
	if (cursors_tk_tt.left.isDown)
	{   ftok_tt_player.body.velocity.x = -200;
	ftok_tt_player.play('pleft');
	}
	else if (cursors_tk_tt.right.isDown)
	{   ftok_tt_player.body.velocity.x = 200;
	ftok_tt_player.play('pright');
	}
	else if (cursors_tk_tt.up.isDown)
	{   ftok_tt_player.body.velocity.y = -200;
	ftok_tt_player.play('pup');
	}
	else if (cursors_tk_tt.down.isDown)
	{   ftok_tt_player.body.velocity.y = 200;
	ftok_tt_player.play('pdown');
	}
	else
	{   ftok_tt_player.animations.stop();//키 입력이 없으면 애니메이션도 멈춰야만 한다.
	}
	//각종 충돌이벤트에 대한 설정
	this.game.physics.arcade.collide(ftok_tt_player, f_treeG);//유저와 울타리
	this.game.physics.arcade.collide(ftok_tt_player, ftok_tt_pines);//유저와 파인애플들(미구현)
	this.game.physics.arcade.collide(ftok_tt_player, ftok_tt_colboxes);//유저와 충돌상자(이동범위제한)
	this.game.physics.arcade.collide(ftok_tt_player, ftok_tt_exit, escape_tk_tt, null, this);//유저와 출구
	this.game.physics.arcade.collide(ftok_tt_player, ftok_tt_surround, colevent_tk_tt, null, this);//유저와 최초도움말 트리거용 충돌상자
	this.game.physics.arcade.collide(ftok_tt_player, guidered_tk_tt, covers_tk_tt);//유저와 가이드용 레드
	this.game.physics.arcade.collide(ftok_tt_player, ftok_tt_boss, start_tk_tt, null, this);//유저와 최종보스
	this.game.physics.arcade.collide(ftok_tt_player, eventbox1_tk_tt, hinder_tk_tt1, null, this);//유저와 이벤트박스1
	this.game.physics.arcade.collide(ftok_tt_player, eventbox2_tk_tt, hinder_tk_tt2, null, this);//유저와 이벤트박스2
	this.game.physics.arcade.collide(ftok_tt_player, eventbox3_tk_tt, hinder_tk_tt3, null, this);//유저와 이벤트박스3
	this.game.physics.arcade.collide(ftok_tt_player, eventbox4_tk_tt, hinder_tk_tt4, null, this);//유저와 이벤트박스4
	this.game.physics.arcade.collide(ftok_tt_player, eventbox4_tk_tt, hinder_tk_tt4, null, this);//유저와 이벤트박스4
};//update 종료
function hinder_tk_tt1(){//이벤트박스와 부딫히면 만들어져있던것들이 보이게된다.
		hinderbox1.events.onInputDown.add(hinder_atk_tk_tt1);
		hinderbox1.visible = true;//텍스트박스(클릭대상)
		hinder1_tk_tt.visible = true;//해당 전보스의 모습
		hindertext1.visible= true;//텍스트
}
function hinder_tk_tt2(){
		hinderbox2.events.onInputDown.add(hinder_atk_tk_tt2);
		hinder2_tk_tt.visible = true;
		hinderbox2.visible = true;
		hindertext2.visible= true;
}
function hinder_tk_tt3(){
	hinderbox3.events.onInputDown.add(hinder_atk_tk_tt3);
	hinder3_tk_tt.visible = true;
	hinderbox3.visible = true;
	hindertext3.visible= true;
}
function hinder_tk_tt4(){
	hinderbox4.events.onInputDown.add(hinder_atk_tk_tt4);
	hinder4_tk_tt.visible = true;
	hinderbox4.visible = true;
	hindertext4.visible= true;
}
function hinder_atk_tk_tt1(){
	eventbox1_tk_tt.destroy(true);//상자는 없애준다.
	hinderbox1.destroy(true);
	hindertext1.destroy(true);
}
function hinder_atk_tk_tt2(){
	eventbox2_tk_tt.destroy(true);
	hindertext2.destroy(true);
	hinderbox2.destroy(true);
}
function hinder_atk_tk_tt3(){
	eventbox3_tk_tt.destroy(true);
	hindertext3.destroy(true);
	hinderbox3.destroy(true);
}
function hinder_atk_tk_tt4(){
	eventbox4_tk_tt.destroy(true);
	hindertext4.destroy(true);
	hinderbox4.destroy(true);
	ftok_tt_boss.visible = true;
}

//건드리지 않아도 되는 함수들==========================================================================================================건드리지 않아도 되는 함수들
//변수이름 빼고는 딱히 수정할 필요 없다

//보스와의 충돌에서 호출되는 함수---------------------------------------------------------
function battle_tk_tt(){
	if(episodeKey == 'tk_tt'){
		this.game.state.start("bosstokyo");
	}else{
		this.game.state.start("bossjako");
	}
}
//최초 도움말과 관련된 함수-------------------------------------------------------------
function colevent_tk_tt(){//보이게 한다.
	spop_window_tk_tt.visible = true;
	spop_button.visible = true;
}
function wipeout_tk_tt(botan){//최초 한번만 필요하니까 없애버린다.
	spop_window_tk_tt.destroy(true);
	ftok_tt_surround.destroy(true);
	botan.destroy(true);
}
//가이드용 블루의 간단설명부터 퇴장까지의 함수-------------------------------------------------
function covers_tk_tt(){//블루와 충돌하면 스탠딩 이미지와 메시지박스가 출력된다.
	ftok_tt_grStand.visible = true;
	ftok_tt_textbox.visible = true;
	ftok_tt_textbox.inputEnabled = true;
	ftok_tt_showtext.visible = true;
	ftok_tt_textbox.events.onInputDown.add(ftok_tt_showtexts);//메시지박스에 클릭이벤트 설정
}
var guidecount1_tk_tt = 1;
function ftok_tt_showtexts(){//메시지박스 클릭으로 호출될때마다 설정된 텍스트의 배열에서 한 덩어리씩 꺼내쓴다. 
	if (ftok_tt_tarray.length > guidecount1_tk_tt) {
		var text = ftok_tt_tarray[guidecount1_tk_tt];
		ftok_tt_showtext.setText(text);
		guidecount1_tk_tt++;
	}else{//배열에 설정된 텍스트들이 모두 사용되면 대화창과 이미지를 없애고 블루를 퇴장시키는 함수를 호출한다.
		ftok_tt_textbox.destroy(true);
		ftok_tt_showtext.destroy(true);
		ftok_tt_grStand.destroy(true);
		redbye_tk_tt();
		guidecount1_tk_tt = 1;
	}
}
function redbye_tk_tt(){
	guidered_tk_tt.body.velocity.y = -200;
	gredup.play();//블루가 올라가는 동작의 애니메이션 재생(무한루프)
}
//보스와 충돌했을 때의 이벤트------------------------------------------------------------
function start_tk_tt(){
	tk_tt_bgm.stop();
	tk_tt_bgm2.play();
	tk_tt_bgm2.loopFull();
	ftok_tt_askingboard.inputEnabled = true;
	if (ftok_sscheck && ftok_plAcheck && ftok_plBcheck) {//selfstudy와 privatelesson수행이 필요하다.
		ftok_tt_askingred.visible = false;//레드의 스탠딩과 대화상자를 보이게 한다.
		ftok_tt_realjako.visible = true;
		ftok_tt_askingboard.visible = true;
		ftok_tt_sftextY.visible = true;
	}else if (ftok_sscheck || ftok_plAcheck && ftok_plBcheck) {//두 학습중 하나라도 했을 경우
		tk_tt_lastStep.x = ftok_tt_player.position.x;
		tk_tt_lastStep.y = (ftok_tt_player.position.y + 5);
		ftok_tt_player.position.x = ftok_tt_player.position.x+5;
		ftok_tt_player.position.y = ftok_tt_player.position.y+5;
		ftok_tt_askingred.visible = true;
		ftok_tt_askingboard.visible = true;
		ftok_tt_sftextN.visible = true;
	}else{//두 학습을 진행하지 않은 상태에서 충돌시
		tk_tt_lastStep.x = ftok_tt_player.position.x;
		tk_tt_lastStep.y = (ftok_tt_player.position.y + 5);
		ftok_tt_player.position.x = ftok_tt_player.position.x+5;
		ftok_tt_player.position.y = ftok_tt_player.position.y+5;
		ftok_tt_askingred.visible = true;
		ftok_tt_askingboard.visible = true;		
		ftok_tt_sftextN.visible = true;

	}
}
sfguide_tk_tt = 1;
function nexttext_tk_tt(){//자코?의 텍스트상자를 클릭했을 때 진행되는 이벤트
	if (ftok_sscheck && ftok_plAcheck && ftok_plBcheck) {//모든 학습을 진행했을 경우
		if (lasbosscript2.length > sfguide_tk_tt) {
			var text = lasbosscript2[sfguide_tk_tt];
			ftok_tt_sftextY.setText(text);
			sfguide_tk_tt++;
		}else{//모든학습 진행자가 텍스트 끝까지 봤다면
			tk_tt_bgm2.stop();
			this.game.state.start("boss");
		}
	}else if (ftok_sscheck || ftok_plAcheck || ftok_plBcheck) {//둘중 하나의 학습만 완료했을 경우
		if (lasbosscript.length > sfguide_tk_tt) {
			var text = lasbosscript[sfguide_tk_tt];
			ftok_tt_sftextN.setText(text);
			sfguide_tk_tt++;
		}else{
			ftok_tt_sftextN.visible=false;
		ftok_tt_ToPL = this.game.add.button(150, 690, 'plbutton',selectPL_tk_tt, this,1,0,1,0);
		ftok_tt_ToPL.scale.setTo(0.3,0.3);
		ftok_tt_ToSS = this.game.add.button(150, 640, 'ssbutton',selectSS_tk_tt, this,1,0,1,0);
		ftok_tt_ToSS.scale.setTo(0.3,0.3);
		backwardbutton_tk_tt = this.add.button(650,700,'btn_backward',backward_tk_tt, this, 1,0,1,0);//뒤로가기버튼
		backwardbutton_tk_tt.scale.setTo(0.3,0.3);
		}
	}else{//둘 다 완료하지 못했을 경우
		if (lasbosscript.length > sfguide_tk_tt) {
			var text = lasbosscript[sfguide_tk_tt];
			ftok_tt_sftextN.setText(text);
			sfguide_tk_tt++;
		}else{
			ftok_tt_sftextN.visible=false;
			ftok_tt_ToPL = this.game.add.button(150, 690, 'plbutton',selectPL_tk_tt, this,1,0,1,0);
			ftok_tt_ToPL.scale.setTo(0.3,0.3);
			ftok_tt_ToSS = this.game.add.button(150, 640, 'ssbutton',selectSS_tk_tt, this,1,0,1,0);
			ftok_tt_ToSS.scale.setTo(0.3,0.3);
			backwardbutton_tk_tt = this.add.button(650,700,'btn_backward',backward_tk_tt, this, 1,0,1,0);//뒤로가기버튼
			backwardbutton_tk_tt.scale.setTo(0.3,0.3);
		}
	}
}
//레드와의 대화이후 버튼을 클릭했다
function selectPL_tk_tt(){//프라이빗레슨은 버튼을 다시 띄운다.
	ftok_tt_ToPL.destroy(true);
	ftok_tt_ToSS.destroy(true);
	ftok_tt_chooseA = this.game.add.button(150,640,'scriptAbutton',selectPA_tk_tt,this,1,0,1,0);
	ftok_tt_chooseA.scale.setTo(0.3,0.3);
	ftok_tt_chooseB = this.game.add.button(150,690,'scriptBbutton',selectPB_tk_tt,this,1,0,1,0);
	ftok_tt_chooseB.scale.setTo(0.3,0.3);
}
function selectSS_tk_tt(){//self study를 선택하면 바로 보낸다.
	ftok_tt_ToPL.visible = false;
	ftok_tt_ToSS.visible = false;
	ftok_tt_ToPL.kill();
	ftok_tt_ToSS.kill();
	tk_tt_bgm2.stop();
	this.game.state.start('selfStudy');
}
function backward_tk_tt(){//뒤로가기 버튼을 눌렀을 경우에 대한 함수
	ftok_tt_askingred.visible = false;//자코 스탠딩
	ftok_tt_askingboard.visible = false;//자코 대화창
	ftok_tt_askingboard.inputEnabled = false;//자코? 대화창 클릭가능해제
	var temp1 = lasbosscript[0];
	ftok_tt_sftextN.setText(temp1);//텍스트를 처음으로 돌려준다.(학습전)
	var temp2 = lasbosscript2[0];
	ftok_tt_sftextY.setText(temp2);//텍스트를 처음으로 돌려준다.(학습후)
	ftok_tt_ToPL.kill();
	ftok_tt_ToSS.kill();
	backwardbutton_tk_tt.kill();
	sfguide_tk_tt = 1;
	if (ftok_tt_chooseB.exists) {
		ftok_tt_chooseA.kill();
		ftok_tt_chooseB.kill();
	}
}
function selectPA_tk_tt(){//private lesson의 경우. 위와 동일
	selectA = true;//A선택시
	tk_tt_bgm2.stop();
	this.game.state.start('privateLesson',true, false, 'A');
}
function selectPB_tk_tt(){//self study로 보낸다. 일단 보내면 체크변수도 변경
	selectA = false;//B선택시
	tk_tt_bgm2.stop();
	this.game.state.start('privateLesson',true, false, 'B');
}
//필드에서 나가서 다시 관광지 선택화면으로 넘어가려 할 경우 선택에 의한 함수들------------------------------
function escape_tk_tt(){//필드에서 나가려할때 메뉴를 출력한다
	ftok_tt_confbox.visible = true;
	ftok_tt_confirm.inputEnabled = true;
	ftok_tt_confirm.visible = true;
	ftok_tt_cancel.inputEnabled = true;
	ftok_tt_cancel.visible = true;
	ftok_tt_confirm.events.onInputDown.addOnce(byebye_tk_tt,this,0,null);
	ftok_tt_cancel.events.onInputDown.addOnce(hide_tk_tt,this,0,null);
}
function hide_tk_tt(){//위에서 cancel버튼을 클릭했을 때
	ftok_tt_confbox.visible = false;
	ftok_tt_confirm.inputEnabled = false;
	ftok_tt_confirm.visible = false;
	ftok_tt_cancel.inputEnabled = false;
	ftok_tt_cancel.visible = false;
}
function byebye_tk_tt(){//위에서 confirm버튼을 클릭했을 때
	tk_tt_bgm.stop();
	this.game.state.start("tokyo");
}
